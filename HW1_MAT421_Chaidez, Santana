{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a3fbdf71-2d70-4a4f-90f9-7a34c44b2d5a",
   "metadata": {},
   "source": [
    "# Module A (HW 1) - MAT 421 #\n",
    "#### Santana Chaidez ####"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "367e6293-96cb-46d0-974f-bbe3903f9636",
   "metadata": {},
   "source": [
    "***\n",
    "## **Base-N and Binary** ##\n",
    "***"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b27cdf1b-dbe2-4130-b6ba-a8830f396680",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "# importing Python library, NumPy, which fascilitates various forms of scientific computing"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "403f07e5-0cf5-4099-bdf3-99eaf8abc6ec",
   "metadata": {},
   "source": [
    "### Base-10 / Decimal System: ###\n",
    "* The most commonly used numeric system, and the decimal system that we all learn, is a **base-10** system that uses the digits 0-9 as coefficients for various powers of 10\n",
    "* This understanding of the base-10 system can be used to also understand any other **base-N** system, where each number in the system is represented by the list of digits 0-(N-1) and each digit represents the coefficient for a power of N"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1627d99c-49a8-4a8e-99da-087c26506c67",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Decimal expansion of 1234.56 (base-10)\n",
    "1234.56 == 1*10**(3) + 2*10**(2) + 3*10**(1) + 4*10**(0) + 5*10**(-1) + 6*10**(-2)\n",
    "# ^^ Shows each digit of 1234.56 (base-10) as a coefficient of a descending power of 10"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ea141084-3a3c-41ef-953d-742b2f119fd0",
   "metadata": {},
   "source": [
    "### Misc. Base-N Decompositions into Base-10 ###"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "485f61e1-7a69-4758-ba62-4f1003d854a3",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 102 (base-3) = 11 (base-10)\n",
    "1*3**(2) + 0*3**(1) + 2*3**(0) == 11"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "1148f786-9b18-485f-a550-a1726efaa1fa",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 13 (base-13) = 16 (base-10)\n",
    "1*13**(1) + 3*13**(0) == 16"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ec801cf8-6143-4da9-b41e-d2e7d71c9bfc",
   "metadata": {},
   "source": [
    "### Base-2 / Binary: ###\n",
    "* **Binary**, the representation of numbers commonly used by computers, is actually a **base-2** system\n",
    "* The system represents numbers using the digits 0 and 1, which each represent the coefficient for a power of 2\n",
    "* Computers benefit from using only digits 0 and 1 since they can also act as boolean/true-false indicators, and additionally can have arithmetic operations represented using AND, OR, and NOT\n",
    "* Faster and more efficient for computers in many ways, but limits amount of numbers able to be represented depending on amount of bits the computer has\n",
    "\n",
    "### Base-10 to Binary Conversion ###"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "cf96c759-50f1-4f4c-9dca-8c01ceaf1211",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# First want to separate the base-10 number into a sum of powers of 2\n",
    "# e.g. 2^0=1, 2^1=2, 2^2=4, 2^3=8, 2^4=16, 2^5=32, 2^6=64, etc.\n",
    "\n",
    "#Decomposition of 27(base-10) into powers of 2:\n",
    "27 == 16 + 8 + 2 + 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "50b809dc-76b0-43b7-ba3d-a07315f04245",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Next, want to identify the higest power of 2 used and identify the coeffcient for each consecutive power in descending order\n",
    "# For 27 (base-10), the highest power of 2 it contains is 4 --> 2^4 = 16\n",
    "\n",
    "#Rewrite sum in powers of 2 with a coefficient of either 0 or 1:\n",
    "27 == 1*2**(4) + 1*2**(3) + 0*2**(2) + 1*2**(1) + 1*2**(0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "bcf949d4-5878-41e3-95d9-1a17193c9cbf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "27(base-10) = 11011(base-2)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Finally, combine the coefficients to identify the binary/base-2 conversion of 27(base-10)\n",
    "print('27(base-10) = 11011(base-2)')\n",
    "\n",
    "# Check with NumPy Decimal to Binary representation operator\n",
    "'11011' == np.binary_repr(27)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "8b8f81c0-a819-43c1-823c-e6dfff55442c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "True\n",
      "13(base-10) = 1101(base-2)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Let's recap with one more example:\n",
    "# 13(base-10) = 1101(base-2)\n",
    "\n",
    "# Assessing accuracy of base-10 decomposition into base-2\n",
    "print(13 == 8 + 4 + 1)\n",
    "print(13 == 1*2**(3) + 1*2**(2) + 0*2**(1) + 1*2**(0))\n",
    "\n",
    "# Identifying and verifying base-2 conversion\n",
    "print('13(base-10) = 1101(base-2)')\n",
    "'1101' == np.binary_repr(13)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ca5e563-f4f4-42e7-bbe0-f761f2e0de29",
   "metadata": {},
   "source": [
    "### Addition and Multiplication: Binary and Decimal Systems ###\n",
    "Base-2 Arithmetic Remunder:\n",
    "1 1 0 1 **1**  +  1 1 0 **1**  -->  1 + 1 = 10 --> We would put a 0 in this first place within the sum and \"carry the one\" to the next highest place as we would for a sum of 10 or more in decimal addition!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "916c46ed-20f1-4016-90c5-8eb6484cd022",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "40(base-10) = 101000(base-2)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Base-10: 27 + 13 = 40\n",
    "# Base-2: 11011 + 1101 = 101000\n",
    "\n",
    "# Base-10 decomposition into base-2\n",
    "print(40 == 1*2**(5) + 0*2**(4) + 1*2**(3) + 0*2**(2) + 0*2**(1) + 0*2**(0))\n",
    "\n",
    "# Check for accuracy:\n",
    "print('40(base-10) = 101000(base-2)')\n",
    "'101000' == np.binary_repr(40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "d133c999-e773-4d32-bb75-181c142e57c7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "351(base-10) = 101011111(base-2)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Base-10: 27 * 13 = 351\n",
    "# Base-2: 11011 * 1101 = 101011111\n",
    "\n",
    "# Base-10 decomposition into base-2\n",
    "print(351 == 1*2**(8) + 0*2**(7) + 1*2**(6) + 0*2**(5) + 1*2**(4) + 1*2**(3) + 1*2**(2) + 1*2**(1) + 1*2**(0))\n",
    "\n",
    "# Check for accuracy:\n",
    "print('351(base-10) = 101011111(base-2)')\n",
    "'101011111' == np.binary_repr(351)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e52a5aa6-7070-4c5c-96e6-95621cecc3aa",
   "metadata": {},
   "source": [
    "***\n",
    "## **Floating Point Numbers** ##\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8e491e37-2791-439f-8d83-98789ed10301",
   "metadata": {},
   "source": [
    "* Floating point numbers, or float, are how we expand the range of values computers can use in operations and calculations with the same amount of bits\n",
    "* Expands the range beyond just positive integers to account for decimals and negative values\n",
    "* Floats are commonly mapped using the **IEEE754** system. For 64-bit systems, this means 1 bit/digit is the sign indicator **s**, the next 11 bits determine the chracteristic/exponent **e**, and the final 52 bits determine the fraction **f** in the following format:\n",
    "* floating point n = (-1)^s x 2^(e-1023) x (1+f)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "63280dcf-856e-4684-af63-a4b6b52a18db",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 10000000001 1010000000000000000000000000000000000000000000000000 (IEEE754) =\n",
      "-6.5\n"
     ]
    }
   ],
   "source": [
    "# IEEE754 to Decimal Conversion\n",
    "# 1 10000000001 1010000000000000000000000000000000000000000000000000 (IEEE754) = -6.5 (base-10)\n",
    "\n",
    "# Idenitfy s, e, and f:\n",
    "s_1 = 1\n",
    "e_1 = 1*2**(10) + 1*2**(0)\n",
    "f_1 = 1/(2**1) + 0/(2**2) + 1/(2**3)\n",
    "\n",
    "# Plug into IEEE754 float representation:\n",
    "n_1 = (-1)**s_1 * 2**(e_1-1023) * (1+f_1)\n",
    "print('1 10000000001 1010000000000000000000000000000000000000000000000000 (IEEE754) =')\n",
    "print(n_1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "7e05fb2c-391c-4914-a647-895f299618f8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "True\n",
      "True\n",
      "7 (base-10) = 0 10000000001 1100000000000000000000000000000000000000000000000000 (IEEE754)\n"
     ]
    }
   ],
   "source": [
    "# Decimal to IEEE754 Conversion\n",
    "# 7 (base-10) = 0 10000000001 1100000000000000000000000000000000000000000000000000 (IEEE754)\n",
    "\n",
    "# 7 is a positive number, so\n",
    "s_2 = 0\n",
    "# 1st bit = 0\n",
    "\n",
    "# The largest power of 2 that goes into 7 is 4 (2^2), so the exponent is 2\n",
    "e_2 = 2\n",
    "# Convert e+1023 = 1025(base 10) into Binary form 10000000001(base-2):\n",
    "print(1025 == 1*2**10 + 1*2**0)\n",
    "# Next 11 bits = 10000000001\n",
    "\n",
    "# Solve for fraction portion:\n",
    "print(7/2**e_2 - 1 == 0.75)\n",
    "# Convert 0.75(base-10) into form of f:\n",
    "f_2 = 1/(2**1) + 1/(2**2)\n",
    "print(f_2 == 0.75)\n",
    "# Final 52 bits = 1100000000000000000000000000000000000000000000000000\n",
    "\n",
    "#Combine found binary values to compile IEEE754 conversion:\n",
    "print('7 (base-10) = 0 10000000001 1100000000000000000000000000000000000000000000000000 (IEEE754)')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "94337e79-bcaf-4499-ae1e-64c895b75f26",
   "metadata": {},
   "source": [
    "* Due to the fraction component of the floating point formula, there are gaps between each value that can be computed using this system\n",
    "* And due to the exponential in this formuala, the gap between values gets larger with the values being computed\n",
    "* Values within these gaps are assigned to their nearest \"neighbor\" value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "8160f044-368e-450c-a029-eaf067a5eee3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.862645149230957e-09\n"
     ]
    }
   ],
   "source": [
    "# Computing the gap between neighboring values at given large number, 1e7\n",
    "gap = np.spacing(1e7)\n",
    "print(gap)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "d94ecc40-7a57-45a1-9e81-13dfc587d543",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Verifying gap by adding less than half of the gap value back to 1e7\n",
    "1e7 == 1e7 + (gap/2.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7723b28e-0c92-4118-83c8-977908e6e506",
   "metadata": {},
   "source": [
    "* Due to system limitations dependent on the amount of bits available, there is still a smallest and largest decimal value that a computer can recognize in its computations\n",
    "* Numbers greater than the largest representable floating point number for a system result in **overflow**, where the result is aassigned to the value of infinity (**inf**)\n",
    "* Number less than the smallest representable float result in **underflow**, where the assigned result is **0**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "edcc68ad-9f73-4dc2-81c4-2b1d0b94cc45",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import sys\n",
    "sys.float_info\n",
    "# Displays float information and specifications for our system"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "718bc495-15d9-4216-91b8-0796f93276bf",
   "metadata": {},
   "source": [
    "The previous output identifies the **largest** representable floating point number as `sys.float_info.max = 1.7976931348623157e+308` amd the **smallest** representable floating point number as `sys.float_info.min = 2.2250738585072014e-308`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "448acd8b-fcc4-4452-adec-b5ecc8e38b58",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "inf"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Displaying overflow\n",
    "2 * sys.float_info.max"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "707df096-cfee-4668-8519-07812ae9c715",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Displaying underflow\n",
    "2**(-500) * sys.float_info.min"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b22eed37-8253-4fca-bd8d-10630c1922b5",
   "metadata": {},
   "source": [
    "***\n",
    "## **Round-Off Errors** ##\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a964507-5fe0-4d3b-9b27-89ffd5e80183",
   "metadata": {},
   "source": [
    "* A result of using base-2 fractions to represent floating point numbers is that the numbers must be approximated according to the finite number of bytes used by the computer\n",
    "* This results in a **round-off error**, which is the difference between the computer's approximation of the number and it's true value\n",
    "* This approximation causes small errors in arithmetic operations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "529c1ada-76d9-4610-9bfc-0439f6e35d89",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.03500000000000014"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# As an example, let's start with a small difference between 2 decimal numbers\n",
    "3.7 - 3.665"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "dd29d8c9-b2ef-4068-9d96-7b941c8af248",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# However, we know the difference should just be 0.035, but the system will not agree\n",
    "3.7 - 3.665 == 0.035"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e9edd0ec-5f65-4222-974e-18118579baf7",
   "metadata": {},
   "source": [
    "* This is the result of the round-off error that occurs during the operation due to the floating point numbers being represented by approximations!\n",
    "* We can observe more comparable results by rounding"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "5e34c3c7-b76a-41bf-9938-0300f1ec947b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "False\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(0.1 + 0.2 + 0.4 == 0.7)\n",
    "# Despite us knowing this is accurate, the output will read False due to error\n",
    "\n",
    "round(0.1 + 0.2 + 0.4, 5) == round(0.7, 5)\n",
    "# But rounding both operations will make them equivalent to the computer!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2594d0a-3119-4755-bd32-b9922828c1f6",
   "metadata": {},
   "source": [
    "* This round-off error can accumulate and be amplified by repeated calculations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "2bb917aa-fa0b-4459-99bf-699316453dab",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.0"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Let's take, for example, the operation 1 + 1/3 - 1/3\n",
    "1 + (1/3) - (1/3)\n",
    "# Done just once, the operation correctly produces a result of 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "b4442dc9-802b-4890-ad6a-f1b597f21101",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Now, let's try repeating this operation with an iterative function defined using for loops\n",
    "def add_sub(iterations):\n",
    "    result = 1\n",
    "    # setting the initial (correct) result\n",
    "    \n",
    "    for i in range(iterations):\n",
    "        result += 1/3\n",
    "        # adds 1/3 to result of previous iteration\n",
    "        \n",
    "    for i in range(iterations):\n",
    "        result -= 1/3\n",
    "        # subtracts 1/3 from result pf previous iteration\n",
    "    \n",
    "    return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "cdb7334c-cf32-44f6-99db-68fb1bb1cc4a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.0000000000000002\n",
      "1.0000000000000064\n",
      "1.0000000000001166\n",
      "0.9999999999727986\n"
     ]
    }
   ],
   "source": [
    "# We can observe how the round-off error accumulates by running this operation for an increasing number of iterations\n",
    "\n",
    "print(add_sub(100))\n",
    "# repeatedly adding and subtracting 1/3 from 1 100 times\n",
    "\n",
    "print(add_sub(1000))\n",
    "# repeatedly adding and subtracting 1/3 from 1 1000 times\n",
    "\n",
    "print(add_sub(10000))\n",
    "# repeatedly adding and subtracting 1/3 from 1 10000 times\n",
    "\n",
    "print(add_sub(1000000))\n",
    "# repeatedly adding and subtracting 1/3 from 1 one million times"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "421ad481-955d-4c04-8282-83b1650337ac",
   "metadata": {},
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
